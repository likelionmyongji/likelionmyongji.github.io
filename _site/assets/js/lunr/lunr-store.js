var store = [{
        "title": "자바스크립트 입문 제 0강",
        "excerpt":"자바스크립트란?   JavaScripts는 웹 브라우저에서 사용하기 위해 만들어진 프로그래밍 언어입니다. 이 언어는 웹 브라우저 상에서 나타나는 UI(사용자 인터페이스)를 동적으로 보여주기 위해 사용됩니다. 최근에는 브라우저 뿐만 아니라 Node.js 런타임을 통해 서버 쪽에서도 사용되고 있습니다.   또한,  NW.js, Electron 등을 통해 데스크탑 앱을 만들 수도 있고, react-native, NativeScript 등으로 모바일 앱도 만들 수 있습니다.   JavaScript는 매년마다 새로운 문법들이 나오며 나날히 발전해 가고 있습니다. 명지대학교(서울) 멋쟁이사자처럼에서는 명지대 아기사자들이 쉽게 JavaScript를 이해할 수 있도록 교안을 정리해 올려보고자 합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture0/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 1강",
        "excerpt":"Hello JavaScript!   자바스크립트는 브라우저에서 언제든지 사용해 볼 수 있습니다. 만약 크롬브라우저가 아닌 다른 브라우저를 사용중이라면 크롬을 설치하여 실행해보세요. 그리고 개발자 도구를 열어보세요.   개발자 도구는           윈도우 Ctrl + Shift + I     macOS Command + Option + I      키를 눌러서 열 수 있습니다.     탭에서 Console을 선택하고 다음 코드를 입력창에 입력해보세요.  console.log('HelloLion!');     여기서 console.log는 Console에 특정 내용을 출력하는 명령입니다.     다음으로 아래의 코드를 입력해볼까요?   console.log(1 + 2);   Console에 3이 출력됨에 따라 우리는 JavaScript로 연산을 할 수 있다는 것을 알 수 있습니다.     이제, 여러분이 원하는 내용을 한번 출력해보세요.   console.log('명지대학교(서울) 멋쟁이사자처럼 7기 화이팅');     이번 교안의 내용은 여기까지입니다.   다음 교안에서는 JavaScript의 변수와 상수에 대해 알아보겠습니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture1/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 2강",
        "excerpt":"변수와 상수      이번 교안부터 CodeSandBox에서 진행하겠습니다. index.js에 있는 내용을 모두 지우고 코드를 작성하고, 오른쪽 Console에서 결과값을 확인하시면 됩니다.      변수와 상수는 특정 이름에 특정 값을 담을 때 사용합니다.   예를 들어서 lion이라는 변수에 1이라는 값을 넣는다고 가정해봅시다. 그러면 코드를 이렇게 입력하면 됩니다.   let lion = 1; console.log(lion);   결과창에 1이라는 값이 나오는 것을 확인하셨나요?   특정 이름에 특정 값을 선언하는 것, 우리는 이를 선언이라고 합니다. 쉽게 설명하자면 lion이라는 값을 이제부터 1이라고 정해주는 것입니다.   값을 선언 할 때에는 두 가지 종류가 있는데 하나는 변수, 다른 하나는 상수입니다.     변수  변수는 바뀔 수 있는 값으로, 한번 값을 선언하고서 다른 값으로 바꿀 수 있습니다.   let lion = 1; console.log(lion); lion = 'likelion'; console.log(lion);   Console에서 1과 ‘likelion’이 각각 출력되는 것을 확인하셨나요?   변수를 선언 할 때에는 이렇게 let 이라는 키워드를 사용합니다. 사용 하실 때 주의 할 점은 같은 블록 범위 내에서 한번 선언했으면 똑같은 이름으로 선언하지 못합니다.   이런 코드는 오류가 발생합니다.   // SyntaxError: Cannot declare a let variable twice: 'lion'. let lion = 1; let lion = 'likelion';     상수   상수는, 한번 선언하고 값이 바뀌지 않아 값이 고정적입니다. 상수를 선언 할 때에는 다음과 같이 선언합니다.   const lion = 1;   상수를 선언 할 때에는 이렇게 const 이라는 키워드를 사용합니다. 상수를 선언하고 나면, 값을 바꿀 수 없습니다.   이런 코드는 오류가 발생합니다.   // TypeError: Attempted to assign to readonly property. const lion = 1; lion = 'likelion';   “Attempted to assign to readonly property.” 라는 오류가 발생했습니다. 이는 한번 상수로 선언했으면 값을 바꿀 수 없음을 의미합니다.   상수를 선언할 때에도 마찬가지로 한번 선언했으면 같은 이름으로 선언 할 수 없습니다.   // SyntaxError: Cannot declare a const variable twice: 'lion'. const lion = 1; const lion = 'likelion';     추가, var   예전에 JavaScript를 공부했던 분이시라면 var를 알고 계실 것입니다.   모던 JavaScript에서는 더 이상 사용되지 않습니다.     데이터 타입   JavaScript에서 데이터 타입은 아래와 같이 네 종류로 이루어져 있습니다.           숫자 (Number)     문자열 (String)     참/거짓 (Boolean)     null &amp; undefinded      숫자는 위에서 작성해보았듯이 바로 값을 대입해 주면 됩니다.   let lion = 1;   문자열은 작은따옴표(‘’) 또는 큰따옴표(““)로 감싸서 선언합니다.   let myongji = '띵지';   Boolean은 Python에서 다루었듯이 참 혹은 거짓 두가지 종류의 값만을 나타낼 수 있습니다.   let coding = true; let sleep = false;   여기서 참은 true, 거짓은 false입니다.   null과 undefinded는 JavaScript에서 ‘없음’을 나타냅니다.   둘의 용도는 살짝 다른데 null은 ‘값이 없음’을 나타내고,   // null const friend = null;   undefinded는 ‘아직 값이 설정되지 않음’을 뜻합니다.   // undefinded let lion; console.log(lion);   null 과 undefined 는 둘 다 값이 없음을 의미하는건 맞는데, null 은 우리가 없다고, 고의적으로 설정하는 값을 의미하고, undefined 는 우리가 설정을 하지 않았기 때문에 없는 값을 의미합니다.     이번 교안의 내용은 여기까지입니다.   다음 교안에서는 JavaScript의 연산자에 대해 알아보겠습니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture2/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 3강",
        "excerpt":"연산자   연산자는 프로그래밍 언어에서 특정 연산을 하도록 하는 문자입니다.   예를 들어   let lion = 1; // 변수의 선언 lion = 2; // 대입 연산자   여기서 두 번째로 사용된 =문자도 연산자의 한 종류입니다.   아래에서는 연산자의 종류에 대해 자세히 알아보도록 하겠습니다.     연산자의 종류는 아래와 같습니다.           산술 연산자     대입 연산자     논리 연산자     비교 연산자      산술 연산자   산술 연산자는 사칙연산과 같은 작업을 하는 연산자입니다.           + : 덧셈     - : 뺄셈     * : 곱셈     / : 나눗셈      위 네 연산자가 가장 기본적인 산술 연산자입니다.   예를 들어   let sum = 1 + 2; console.log(sum); // 3   위의 코드는 sum이라는 변수를 선언할 때 1 + 2의 결과값을 담습니다. 따라서 Console에는 3이 출력됩니다.   let sum = 1 + 2 * 3 - (4 / 2); console.log(sum); // 5   우리는 위와 같이 조금 더 복잡한 사칙연산도 실행할 수 있습니다.   또한, 다른 프로그래밍 언어에서도 살펴 보았듯이 ++ 같은 연산자도 산술 연산자에 포함됩니다.   let sum = 1; console.log(sum++); // 1 console.log(++sum); // 2   ++은 변수 이름 앞에 오면 1을 더한 다음의 값을 보여주고, 변수 이름 뒤에 오면 1을 더하기 직전의 값을 보여준다는 점에서 차이가 있습니다.   덧셈 외에도 뺄셈도 똑같이 할 수 있습니다.   let sum = 1; console.log(sum--); // 1 console.log(--sum); // 0   대입 연산자   대입 연산자는 변수에 연산한 값을 바로 할당할 때 사용되는 연산자입니다.   예를 들어   let a = 1; a = a + 3;   위와 같은 코드는 다음과 같이 작성할 수 있습니다.   let a = 1; a += 3;   덧셈 이외의 다른 연산자에서도 동일하게 적용 가능합니다.   let a = 1; a += 3; a -= 3; a *= 3; a /= 3; console.log(a); // 1   논리 연산자   논라 연산자는 Boolean Type을 위한 연산자입니다.   논리 연산자로는 세 가지가 있습니다.           ! : NOT     &amp;&amp; : AND     || : OR      논리 연산자는 NOT, AND, OR 연산자 순으로 계산합니다.   NOT 연산자는 값이 true면 false로, false면 true를 반환합니다.   let notT = !false; // true let notF = !true; // false   AND 연산자는 양쪽의 값이 둘다 true 일때만 true입니다.   let andT = true &amp;&amp; true; // true let andF = true &amp;&amp; false; // false   OR 연산자는 양쪽의 값 중 하나라도 true이면 true입니다.   let orT = true || false; // true let orF = false || false; // false   비교 연산자   비교 연산자는 두 값을 비교할 때 사용합니다. 값이 같으면 true, 아니면 false를 반환합니다.   ===는 두 값이 일치하고, 타입도 같은지 검사합니다.   const a = 1; const b = '1'; const c = '1'; console.log(a === b); // false console.log(b === c); // true   ==은 두 값이 같은지 비교하지만 타입 검사는 하지 않습니다.   const a = 1; const b = '1'; const c = '1'; console.log(a == b); // true console.log(b == c); // true   앞으로 여러분이 두 값이 일치하는지 비교 할 때에는 ==대신 === 를 사용 할 것을 권장 드립니다. == 를 사용하다보면 실수를 할 확률이 높아집니다.   두 값이 일치하지 않는지 확인할 때에도 위와 비슷하게 !==를 사용하면 됩니다.   const a = 1; const b = '1'; const c = '2'; console.log(a !== b); // true console.log(b !== c); // true   마찬가지로 !=를 사용하면 타입 검사를 하지 않습니다.   const a = 1; const b = '1'; const c = '2'; console.log(a != b); // false console.log(b != c); // true   여러분이 두 값이 일치하지 않는지 비교 할 때에는 !=대신 !== 를 사용 할 것을 권장 드립니다. != 를 사용하다보면 실수를 할 확률이 높아집니다.   두 값 중에서 무엇이 더 크고 작은지 비교하기 위해서는 아래와 같은 연산자를 사용할 수 있습니다.   const a = 1; const b = 2; const c = 2; console.log(a &lt; b); // true console.log(b &gt; a); // true console.log(b &gt;= c); // true console.log(a &lt;= c); // true console.log(b &lt; c); // false     주석   코드에 메모를 달고 싶을 때에는 아래와 같이 작성할 수 있습니다. 이를 주석이라고 합니다.   // 이것은 주석입니다.   주석은 여러 줄로도 작성할 수 있습니다.   /*      이것은 여러 줄 주석입니다. */     문자열 붙이기   단순히 두 문자열을 붙일 때에는 +을 사용합니다.   const like = '멋쟁이'; const lion = '사자처럼'; console.log(like + lion); // 멋쟁이사자처럼     이번 교안의 내용은 여기까지입니다.   다음 교안에서는 JavaScript의 조건문에 대해 알아보겠습니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture3/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 4강",
        "excerpt":"조건문   조건문을 사용하면 특정 조건이 만족됐을 때 코드를 실행할 수 있습니다.   조건문의 종류는 아래와 같습니다.           if문     switch/case문        if문   if문은 괄호의 조건식이 만족하면 코드를 실행합니다.   const lion = 7; if(lion === 7) {     console.log('멋쟁이사자처럼 7기'); }   결과는 ‘멋쟁이사자처럼 7기’가 Console에 출력됩니다.   만약 lion의 값이 7이 아닌 다른 값이면 결과가 어떻게 나올까요?   const lion = 6; if(lion === 7) {     console.log('멋쟁이사자처럼 7기'); }   결과를 확인해보셨나요? 아무것도 출력되지 않습니다.   if문의 기본 구조는 아래와 같습니다.   if(/* 조건식 */) {     // 만족하면 실행되는 코드; }   조건식을 만족하면 실행되는 코드가 중괄호 {}로 감싸져 있는데, 이를 코드블럭이라고 합니다.   만약 조건식의 결과가 true이면 코드 블럭 내의 코드가 실행되고, false면 실행되지 않습니다.   if-else문   만약 특정 조건이 만족할 때와 만족하지 않을 때에 서로 다른 코드를 실행해야 한다면 어떻게 해야 할까요? 바로 if-else문을 사용하면 됩니다.   const lion = 6; if(lion === 7) {     console.log('멋쟁이사자처럼 7기'); } else {     console.log('7기가 아니시군요!'); }   위의 코드의 결과는 Console에 ‘7기가 아니시군요!’라고 출력이 됩니다.   if-else if문   여러 조건에서 여러 작업을 수행하려면 if-else if문을 사용합니다.   const lion = 5; if(lion === 7) {     console.log('멋쟁이사자처럼 7기'); } else if(lion === 6) {     console.log('멋쟁이사자처럼 6기'); } else if(lion === 5) {     console.log('멋쟁이사자처럼 5기'); } else if((lion &lt;= 4)) {     console.log('멋사 할아버지..?'); } else {     console.log('멋사가 아니시군요!'); }   switch/case문   여러 조건에서 여러 작업을 수행할 때, switch/case문을 사용할 수도 있습니다.   const job = 'front-end'; switch (job) {   case 'front-end':     console.log('프론트엔드 개발자');     break;   case 'back-end':     console.log('백엔드 개발자');     break;   case 'designer':     console.log('디자이너');     break;   case 'director':     console.log('기획자');     break;     default:     console.log('다른 일을 하시나봐요?'); }   switch/case 문은 이와 같이 특정 값이 무엇이냐에 따라 다른 작업을 수행 할 수 있게 해줍니다.   switch/case 문에서는 각 case 에서 실행할 코드를 작성하고 맨 마지막에 break; 를 해주어야 합니다. break 를 하지 않으면 그 다음 case 의 코드까지 실행해버립니다.   그리고, 맨 아래의 default: 는 job 값이 우리가 case 로 준비하지 않은 값일 경우를 의미합니다.     이번 교안의 내용은 여기까지입니다.   다음 교안에서는 JavaScript의 함수에 대해 알아보겠습니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture4/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 5강",
        "excerpt":"함수   함수는 JavaScript 뿐 만 아니라 대부분의 프로그래밍 언어에서 핵심입니다. 함수는 학교 수학시간에 배웠던 것처럼 y = f(x)의 형태라고 생각하시면 될 것 같습니다.   예를 들어서 우리가 두 값의 합을 구하고 싶을 때 아래와 같은 코드를 작성합니다.   const a = 1; const b = 2; const sum = a + b;   이러한 코드를 함수를 통해 만들어 보겠습니다.   function add(a, b) {   return a + b; }  const sum = add(1, 2); console.log(sum);   함수를 만들 때는 function 키워드를 사용하며, a, b와 같이 괄호 안에 함수에서 어떤 값을 받아올지 정해주는데 이것을 파라미터(매개변수)라고 합니다.   함수 내부에서 return키워드를 사용하여 함수의 결과물을 지정 할 수 있습니다. return을 하게 되면 함수가 끝나 return 아래의 코드는 호출되지 않습니다.     템플릿 리터럴   우리는 Console에서 문자열을 조합하기 위해서 아래와 같이 +문자를 사용했었습니다.   function hello(name) {   console.log('Hello, ' + name + '!'); } hello('lion');   +문자를 사용해도 좋지만 es6에서 템플릿 리터럴 문법을 사용하여 더욱 간단하게 조합할 수 있게 되었습니다.   function hello(name) {   console.log(`Hello, ${name}!`); } hello('lion');     화살표 함수   함수를 function 키워드 대신에 =&gt;문자를 사용해서도 만들 수 있습니다. 이를 화살표 함수라고 합니다.   const add = (a, b) =&gt; {   return a + b; };  console.log(add(1, 2));   코드 블록 내부에서 바로 return을 하는 경우 아래와 같이 줄여서 쓸 수 있습니다.   const add = (a, b) =&gt; a + b; console.log(add(1, 2));     이번 교안의 내용은 여기까지입니다.   다음 교안에서는 JavaScript의 객체에 대해 알아보겠습니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture5/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 6강",
        "excerpt":"객체   객체는 변수나 상수를 사용할 때에 하나의 이름에 대해 여러 종류의 값을 넣을 수 있게 해줍니다.   const jeonghun = {     name: '반정훈',     age: 21,     likelion: 7 };  console.log(jeonghun.name); // 반정훈 console.log(jeonghun.age);  // 21 console.log(jeonghun.likelion);  // 7   객체를 선언 할 때에는 이렇게 { } 문자 안에 원하는 값들을 넣어주면 됩니다. 값을 집어 넣을 때에는 키(Key) : 원하는 값(Value)의 형태로 넣으며, 키에 해당하는 부분은 공백이 없어야 합니다.   const mansu = {     'coding everyday': false };   만약에 공백이 있어야 하는 상황이라면 이를 따옴표로 감싸서 문자열로 넣어주면 됩니다.     함수에서 파라미터로 객체 받기   위에서 만든 객체를 함수의 파라미터로 받아와 봅시다.   const jeonghun = {     name: '반정훈',     age: 21,     likelion: 7 };  function hello(lion){     const text = `안녕하세요, 저는 ${lion.name}(${lion.age})입니다. 멋사 ${lion.likelion}기 입니다.`     console.log(text); }  hello(jeonghun);  /*     안녕하세요, 저는 반정훈(21)입니다. 멋사 7기 입니다. */     객체 비구조화 할당(객체 구조 분해)   위에서 본 함수에서 파라미터로 받아온 값을 조회할 때마다 ${lion.name}와 같이 쓰고 있는데, 객체 비구조화 할당을 통해 아래와 같이 코드를 더욱 간결하게 작성할 수 있습니다.   const mansu = {     name: '김만수',     age: 21,     likelion: 7 };  function hello(lion){     const { name, age, likelion } = lion; // 객체에서 값을 추출해 새로운 상수로 선언     const text = `안녕하세요, 저는 ${name}(${age})입니다. 멋사 ${likelion}기 입니다.`     console.log(text); }  hello(mansu);  /*     안녕하세요, 저는 김만수(21)입니다. 멋사 7기 입니다. */   파라미터 단계에서 객체 비구조화 할당을 하면 더욱 깔끔한 코드를 볼 수 있습니다.   const mansu = {     name: '김만수',     age: 21,     likelion: 7 };  function hello({ name, age, likelion }){     const text = `안녕하세요, 저는 ${name}(${age})입니다. 멋사 ${likelion}기 입니다.`     console.log(text); }  hello(mansu);  /*     안녕하세요, 저는 김만수(21)입니다. 멋사 7기 입니다. */     객체 내부 함수   아래와 같이 객체 내부에 함수를 넣을 수도 있습니다. 함수를 선언 할 때에는 이름이 없어도 됩니다.(주의: 객체 안에 함수를 넣을 때, 화살표 함수로 선언한다면 제대로 작동하지 않습니다)   const jeonghun = {     name: '반정훈',     sound: '코딩은 즐거워',     say: function say() { // 또는 say: function() {     console.log(this.sound);   } };  jeonghun.say(); // 코딩은 즐거워   함수가 객체안에 들어가게 되면, this는 자신이 속해있는 객체를 가르키게 됩니다.     이번 교안의 내용은 여기까지입니다.   다음 교안에서는 JavaScript의 배열에 대해 알아보겠습니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture6/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 7강",
        "excerpt":"배열   배열은 JavaScript 객체의 특별한 형태입니다. 배열은 단일 데이터가 아닌 다수의 데이터를 저장할 수 있고, 연관성이 있는 데이터를 같이 저장하므로 저장한 데이터를 찾는데 용이합니다.   예를 들어서 문자열 배열을 선언해봅시다.   const staff = ['김혜현', '황낙주', '반정훈', '한종우'];   배열을 선언할 때에는 위처럼 [ ] 문자로 감싸주면 됩니다.   아래와 같이 객체 배열도 만들 수 있습니다.   const staffs = [{name: '김혜현'}, {name: '황낙주'}, {name: '반정훈'}, {name: '한종우'}];   배열을 선언한 후, n번째 항목을 조회하려면 아래와 같이 하면 됩니다.   staffs[n];  console.log(staffs[0]); // Object {name: '김혜현'}     배열 항목 추가   배열에 새 항목을 추가하려면 배열의 내장 함수 push 함수를 사용하면 됩니다.   const staffs = [{name: '김혜현'}, {name: '황낙주'}, {name: '반정훈'}, {name: '한종우'}];  staffs.push({     name: '???' });     배열 크기 알아내기   배열의 크기를 알고 싶을 때에는 배열의 length 값을 확인하면 됩니다.   const staffs = [{name: '김혜현'}, {name: '황낙주'}, {name: '반정훈'}, {name: '한종우'}];  console.log(staffs.length); // 4   배열은 push 와 length 이외에도 다양한 기능을 가지고 있습니다. 이에 대해서는 코드를 짜 보면서 한 번 찾아보셔도 좋을 것 같아요.     이번 교안의 내용은 여기까지입니다.   다음 교안에서는 JavaScript의 반복문에 대해 알아보겠습니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture7/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 8강",
        "excerpt":"반복문   특정 작업을 반복하려할 때, 우리는 반복문을 사용할 수 있습니다.   반복문의 종류는 아래와 같습니다.           for문     while문        for   for문은 아래와 같은 구조로 이루어져 있습니다.   for (/* 초기 구문; 조건 구문; 변화 구문; */) {   // 코드 }   for문으로 0 부터 9까지의 정수를 출력해봅시다.   for (let i = 0; i &lt; 10; i++) {   console.log(i); }   for 문을 사용 할 때 보통 i++ 를 해서 1씩 증감하는 형태로 사용합니다. i--을 통해 1씩 빼는 형태도 가능합니다.     배열과 for   배열의 여러 기능 중에서 length 값을 통해 for문에서 배열을 활용할 수도 있습니다.   const staff = ['김혜현', '황낙주', '반정훈', '한종우'];  for (let i = 0; i &lt; staffs.length; i++) {   console.log(staffs[i]); }     while   while문은 특정 조건이 참이라면 계속해서 반복하는 반복문입니다. for 문은 특정 숫자를 가지고 숫자의 값을 비교하고, 증감해주면서 반복을 한다면, while문은 조건을 확인만 하면서 반복을 합니다.   위에서 0 부터 9까지 출력하는 반복문을 while문을 통해 작성해보겠습니다.   let i = 0; while (i &lt; 10) {   console.log(i);   i++; }     break &amp; continue   반복문 안에서는 break 와 continue를 통하여 반복문에서 벗어나거나, 그 다음 루프를 돌게끔 할 수 있습니다.   for (let i = 0; i &lt; 10; i++) {   if (i === 4) continue; // 다음 루프를 실행   console.log(i);   if (i === 7) break; // 반복문을 끝내기 }   i 가 4 일땐 continue 를 하여 원래 console.log 를 해야 하지만 그 코드를 수행하지 않고 바로 다음 루프인 5로 넘어갑니다.   i 가 7 일땐 break 를하여 반복문을 종료시킵니다.     이번 교안의 내용은 여기까지입니다.   다음 교안에서는 JavaScript의 프로토타입과 클래스에 대해 알아보겠습니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture8/",
        "teaser":null},{
        "title": "자바스크립트 입문 제 9강",
        "excerpt":"프로토타입과 클래스   객체 생성자   프로토타입과 클래스를 다루기 전에, 객체 생성자에 대하여 알아보겠습니다. 객체 생성자는 함수를 통해서 새로운 객체를 만들고 그 안에 넣고 싶은 값 혹은 함수들을 구현 할 수 있게 해줍니다.   function Lion(name, major, staff) {   this.name = name;   this.major = major;   this.staff = staff;   this.lion = function() {     if(this.staff) {       console.log(\"으른사자 \" + this.name);     } else {       console.log(\"아기사자 \" + this.name);     }   }; }  const jeonghun = new Lion('반정훈', '융소', true); const mansu = new Lion('김만수', '융소', false);  jeonghun.lion(); // 으른사자 반정훈 mansu.lion(); // 아기사자 김만수   객체 생성자를 사용 할 때는 보통 함수의 이름을 대문자로 시작하고, 새로운 객체를 만들 때에는 new 키워드를 앞에 붙여주어야 합니다.   위의 코드에서 jeonghun과 mansu의 lion 함수는 동일한 작업을 수행함에도 불구하고 객체가 생성될 때마다 함수가 새로 생성되어 this.lion으로 설정되고 있습니다.   같은 객체 생성자 함수를 사용하는 경우, 특정 함수 또는 값을 재사용 할 수 있는데 바로 프로토타입입니다.     프로토타입   프로토타입은 아래와 같이 객체 생성자 함수 아래에 .prototype.[키 값] = 코드를 입력하여 설정 할 수 있습니다.   function Lion(name, major, staff) {   this.name = name;   this.major = major;   this.staff = staff; };  Lion.prototype.lion = function(){   if(this.staff) {       console.log(\"으른사자 \" + this.name);     } else {       console.log(\"아기사자 \" + this.name);     } }; Lion.prototype.sharedValue = 1;  const jeonghun = new Lion('반정훈', '융소', true); const mansu = new Lion('김만수', '융소', false);  jeonghun.lion(); // 으른사자 반정훈 mansu.lion(); // 아기사자 김만수     객체 생성자 상속 받기   예를 들어서 우리가 jeonghun 과 mansu 라는 새로운 객체 생성자를 만든다고 가정해봅시다. 그리고, 해당 객체 생성자들에서 Lion 의 기능을 재사용한다고 가정해봅시다. 그렇다면, 아래처럼 구현 할 수 있습니다.   /* 이어서 */  function Staff(name, major) {   Lion.call(this, true, name, major); } Staff.prototype = Lion.prototype;  function Member(name, major) {   Lion.call(this, false, name, major); } Member.prototype = Lion.prototype;  const jeonghun = new Staff('반정훈', '융소'); const mansu = new Member('김만수', '융소');  jeonghun.lion(); // 으른사자 반정훈 mansu.lion(); // 아기사자 김만수   새로 만든 Staff 와 Member 함수에서 Lion.call 을 호출해주고 있는데요, 여기서 첫번째 인자에는 this 를 넣어주어야 하고, 그 이후에는 Lion 객체 생성자 함수에서 필요로 하는 파라미터를 넣어주어야 합니다.   추가적으로 prototype 을 공유해야 하기 때문에 상속받은 객체 생성자 함수를 만들고 나서 prototype 값을 Lion.prototype 으로 설정해주었습니다.     클래스   클래스라는 기능은 C++, Java, C#, PHP 등의 다른 프로그래밍 언어에는 있는 기능인데 자바스크립트에는 없었습니다. 예전 자바스크립트 (ES5) 에서는 클래스 문법이 따로 없어 위에서 작성한 코드처럼 객체 생성자 함수를 사용하여 비슷한 작업을 구현해왔습니다.   ES6 에서부터는 class 라는 문법이 추가되었습니다. 이는 우리가 객체 생성자로 구현했던 코드를 조금 더 명확하고, 깔끔하게 구현 할 수 있게 해줍니다. 또한, 상속도 훨씬 쉽게 해줄 수 있습니다.   class Lion {   constructor(name, major, staff) {     this.name = name;     this.major = major;     this.staff = staff;   }   lion() {     if(this.staff) {       console.log(\"으른사자 \" + this.name);     } else {       console.log(\"아기사자 \" + this.name);     }   } }  const jeonghun = new Lion('반정훈', '융소', true); const mansu = new Lion('김만수', '융소', false);  jeonghun.lion(); // 으른사자 반정훈 mansu.lion(); // 아기사자 김만수   여기서 우리가 lion 이라는 함수를 클래스 내부에 선언하였는데, 이를 ‘메서드’라고 부릅니다. 이렇게 메서드를 만들면 자동으로 prototype 으로 등록이 됩니다.     class 를 사용했을때에는, 다른 클래스를 쉽게 상속 할 수 있습니다.   /* 이어서 */  class Staff extends Lion {   constructor(name, major) {      super(name, major, true);   } }  class Member extends Lion {   constructor(name, major) {      super(name, major, false);   } }  const jeonghun = new Staff('반정훈', '융소'); const mansu = new Member('김만수', '융소');  jeonghun.lion(); // 으른사자 반정훈 mansu.lion(); // 아기사자 김만수   상속을 할 때는 extends 키워드를 사용하며, constructor에서 사용하는 super() 함수가 상속받은 클래스의 생성자를 가르킵니다.     이번 교안의 내용은 여기까지입니다.   명지대 아기사자 여러분, 여기까지 오시느라 수고 많으셨습니다. 어느덧 준비한 자바스크립트 입문의 교안이 모두 끝이 났습니다.   비록 모든 자바스크립트의 문법을 다루어 보지는 못했지만 기본기를 탄탄히 갖출 수 있도록 준비했\b습니다.   이 교안에서 멈추지 마시고 새로운 프로젝트의 시작으로 삼아 부족한 부분은 다른 사람들이 만든 프로젝트를 참고하기도 하면서 경험을 쌓아 가시길 바랍니다.   감사합니다.  ","categories": ["JavaScript"],
        "tags": ["JavaScript","vanillaJS","es6"],
        "url": "http://localhost:4000/javascript/js_lecture9/",
        "teaser":null}]
